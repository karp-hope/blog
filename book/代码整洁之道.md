## 整洁的代码只做好一件事

每个函数，每个类，每个模块都全神贯注于一事情， 整洁的代码应该可由作者之外的开发者阅读和增补，应该包含有单元测试和验收测试。只提供一种而非多种做一件事的途径，只有尽量少的依赖关系，明确的定义和尽量少的API。

如果每次签入的时候，代码都比签出时干净，那么代码就不会腐坏

## 有意义的命名

## 函数
#### 短小
函数的第一规则是要短小，第二条规则是还要更短小

#### 代码块和缩进
if, else, while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。函数不应该大到足以容纳嵌套结构，函数的缩进层级不该多于一层或者两层

#### 只做一件事
函数应该做一件事，做好一件事，只做一件事

#### 每个函数一个抽象层级

#### switch语句
单一权责原则（Single Responsibility Principle, SRP）
开放闭合原则（Open Closed Principle, OCP）
switch问题的解决方案 是将switch语句埋到抽象工厂（注意抽象工厂和工厂方法的区别）底下，不让任何人看到。

一般对于switch语句，如果只出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他的部分看不到，就可以。（当然需要就事论事，不过一般情况下是这样）

#### 函数参数
最理想的参数数量是0，其次是1，再次是2，应尽量避免3；有非常足够特殊的理由才能使用3个以上参数。
从代码层面看，参数不容易对付，他们带有太多概念性；从单元测试角度看，参数甚至更叫人为难，因为组合太多了。对于转换，使用输出函数而非返回值简直令人迷惑。

标识参数：标识参数丑陋不堪；向函数传入布尔值简直就是骇人听闻的做法，这样做，相当于大声宣布函数做的不止一件事

如果函数看来需要2个，3个，或3个以上参数时，就说明一些参数应该分装成类了。

#### 分隔指令与询问
函数要么做什么事情，要么回答什么事，但二者不可兼得。

#### 使用异常替代返回错误码
try catch代码块丑陋不堪，他们搞乱了代码结构，把错误处理与正常流程混为一谈，最好把try catch的主体部分抽离出来，另外形成函数
```
public void delete(Page page){
    try{
        deletePage(page);
    }catch(Exception e){
        logError(e);
    }
}
```

## 注释
什么也比不上良好的注释来的有用，什么也不会比乱七八糟的注释更有本事搞坏一个模块。什么也不会比陈旧，提供错误信息的注释更有破坏性。

#### 注释不能用来美化糟糕的代码
最好用代码来解释其行为，而非用注释

#### TODO注释
TODO是一种程序员认为应该做，但由于某些原因目前还没有做的工作。

#### 注释掉的代码
直接把代码注释掉是讨厌的做法，其他人不敢删除代码。源代码控制系统会记住他们，丢不了

## 格式

## 对象和数据格式
将变量设置为私有有一个理由：我们不想其他人依赖这些变量，那么不应该给对象自动添加赋值器和取值器，将私有化变量公之于众，如同它们根本就是公共变量一般。

#### 数据抽象
隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏实现关乎抽象， 一般我们不远暴露细节，更愿意以抽象形态表述数据。傻乐着乱加取/赋值器是最坏的选择。

#### 数据，对象的反对称性
对象把数据隐藏于抽象之后，暴露操作数据的函数；数据结构暴露其数据，没有提供有意义的函数

对象与数据结构之间的二分原理：过程式代码（使用数据结构的代码）便于在不改动既有数据结构的前提下添加新函数；面向对象代码便于在不改动既有函数的前提下添加新类。

在任何复杂的系统中，都会有需要添加新数据类型而不是新函数的时候，此时对象可能更合适；反之，需要添加新函数而不是新数据类型时，过程式代码和数据结构更合适，个人考虑吧

#### 得墨忒耳律（试用与对象而非数据结构）
模块不应该了解它所操作对象的内部情况

火车失事：A.b().c().d()///连串的调用，这种调用明显也违反了得墨忒耳律
如果b(),c(),d()返回的是数据结构的话，得墨忒耳律不适用，也就可以这样调用，因为数据结构暴露其数据。如果是对象的话，这样的调用可以优化，不要搞得这么多

混杂：某个类一半是对象，一半是数据结构，此种混杂2面不讨好，需要优化

## 错误处理
错误处理很重要，但如果搞乱了代码逻辑，就是错误的做法

#### 使用异常而非返回码
#### 使用不可控异常
可控异常：每个方法都列出它可能传递给调用者的异常。
可控异常的代码是违反了 开放/闭合原则，如果你在方法中抛出可控异常，而catch语句在三个层级之上，那就得在catch语句和抛出异常处之间的每个方法签名上都声明该异常了。

如果你在编写一套关键代码库，则可控异常有时也会有用：你必须捕获异常，但对于一般开发，其依赖成本要高于收益

#### 别返回null值
要谈论错误处理，就一定要提及那些容易引发错误的做法。第一项就是null值，很多时候，一个函数中很多代码都在检查null值。 这种代码看似不坏，其实糟糕透了，返回null值，在给自己增加工作量的同时也给调用者添乱，只要有一处没有检查null值，程序就会失控

如果你打算在方法中返回null值，不如抛出异常，或者返回特例对象（一个代替null值的class，这种我觉得是比较好的）。

#### 别传递null值
在方法中返回null值是糟糕的做法，但是将null值传递给其他的方法就更糟糕了，除非api要求你传null，否则就要尽量避免

## 边界
#### 封装第三方api的调用

#### 学习性测试的好处不只是免费
学习性测试毫无成本。无论如何我们都得学习要使用的API，而编写测试则是获得这些知识的容易而不会影响其他工作的途径。

使用Adapter模式可以很好的封装第三方我们的不太了解的接口来转换成我们需要的熟悉的接口

## 单元测试
TDD三定律：
1.在编写不能通过的单元测试前，不可编写生产代码。
2.只可编写刚好无法通过的单元测试，不能编译也算不通过
3.只可编写刚好足以通过当前失败测试的生产代码

#### 保持测试整洁
测试越脏，就越难修改
没有测试代码组做保障，会开始害怕做改动，并且不再清理生产代码，因为害怕修改；测试使改动变得可能
测试代码和生产代码一样重要，需要被思考，被设计和被照料，应该像生产代码一般保持整洁

#### 整洁的测试
可读性，可读性，可读性

构造-操作-检验模式：第一个环节构造测试数据，第二个环节操作测试数据，第三个环节检验操作是否得到预期的结果

每个测试只测试一个概念

#### F.I.R.S.T 准则
快速（fast）：测试应该足够快
独立（Independent）：测试应该相互独立
可重复（Repeatable）：测试应该可在任何环境中重复通过
自足验证（Self-Validating）：测试应该有 布尔值 输出。无论是否失败，不应该通过查看日志文件来确定是否通过测试。
及时（Timely）：测试应该及时编写。测试应该在恰好使其通过的生产代码之前编写。如果在生产代码之后编写，你会发现生产代码难以测试，这样你可能不会去设计容易测试的生产代码了。这样恶性循环。

## 类
#### 类的组织
我们喜欢保持变量或工具函数的私有性，但并不执着于此；对于我们来说测试说了算； 但是总的来说，我们首先会想办法使之保有隐私。放松封装总是下策。

#### 类应该短小
衡量类的大小，我们应该通过权责来衡量
类的名称应当描述其权责，实际上，命名正是帮助判断类的长度的第一个手段。

单一权责原则（SPR）：类或模块应有且只有一条加以修改的理由
系统应该许多短小的类而不是由少量巨大的类组成，每个小类封装一个权责，只有一个修改理由，并与少数其他的类一起协同达成期望的系统行为。

高内聚，低耦合

将大函数拆成许多小函数，往往也是将类拆分成多个小类的时机，这样可以提高内聚性，当类丧失了内聚性，就拆分它

依赖倒置原则（DIP -- Dependency Inversion Principle）类应该依赖于抽象，而非依赖于具体细节，这样便于解耦。

## 11.系统
#### 将系统的构造和使用分离开（这里感觉好像是跟依赖倒置原则差不多的意思，把具体类的依赖分开？）
这里的系统相当于一个class
抽象工厂
依赖注入：感觉这个概念好像就是把某个依赖从外部传进来（通过构造函数的形式或者赋值器方法来处理某个类中的依赖，搞得好像很高端的样子。。）

AOP(面向切面编程 或者叫 面向方面编程)
#### java代理
java静态代理：若代理类在代码中已经编写了，就相当于静态代理
java动态代理：若代码中没有代理类，通过java的InvocationHandler接口实现的代理，就叫动态代理

## 12.迭进
#### 简单设计规则1：运行所有测试
紧耦合的代码难以编写测试；同样，编写测试越多，就越遵循DIP，SRP之类的规则，使用依赖注入，接口和抽象等工具尽可能减少耦合。如此一来，设计就有长足进步了

#### 简单设计规则2-4：重构
测试消除了对清理代码就会破坏代码的恐惧

不可重复

在写完代码的时候，如果不满意的话，可以花一些时间调整一下代码

## 13.并发编程

## 14.逐步改进

## 15.junit内幕

## 17.味道与启发
#### 注释
#### 函数
永不被调用的函数应该丢弃，保留死代码纯属浪费

#### 重复
每次看到重复，都代表着遗漏了抽象

#### 用多态代替if/else 或switch/case
单个switch原则：对于给定的选择类型，不应有多于一个switch语句，在那个switch语句中的多个case中，必须创建多态对象，取代系统中其他类似的switch语句

#### 不用掩盖时序耦合
如下面这种
```
public void dive(){
    beginA();
    beginB();
    beginC();
}
```
三个函数顺序很重要，必须先执行A，然后B，然后C， 其实可以考虑这样：
```
public void dive(){
    Object A = beginA();
    OBject B = beginB(A);
    beginC(B);
}
```
这样就强制了调用的顺序了~

#### 函数应该只在一个抽象层级上

#### 避免传递浏览
就是所谓的 得墨忒耳律，形如a.getB().getC()这样的形式。 正确的做法是让直接协作者（这里是B）提供所需的全部服务。

#### 不要继承常量

#### 测试
只要还没有被测试探测过的条件，或者是还有没被验证过的计算，测试就还不够。
