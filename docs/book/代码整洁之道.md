## 第一章 整洁代码

***later equals never***：稍后等于永不

***整洁的代码只做好一件事情***

​	*每个函数，每个类，每个模块都全神贯注于一事情， 整洁的代码应该可由作者之外的开发者阅读和增补，应该包含有单元测试和验收测试。只提供一种而非多种做一件事的途径，只有尽量少的依赖关系，明确的定义和尽量少的API*

**童子军军规**：

​	*让营地比你来时更干净；如果每次签入的时候，代码都比签出时干净，那么代码就不会腐坏*



## 第二章 有意义的命名

**名副其实：**

​	如果名称需要注释来补充，那就不算名副其实了

**做有意义的区分**

​	废话是另一种没意义的区分。假如有一个Product类，如果还有一个ProductData/ProductInfo类，那他们的名称虽然不同，意思却相同，Info/Data就像a一样，是意义含混的废话



## 第三章 函数

### 短小

函数的第一规则是要短小，第二规则还是要短小

每个函数只做一件事情，做好一件事

if,else,while语句等，其中的代码块应该只有一行，该行大抵应该是一个函数调用语句

### 只做一件事

*如果函数只是做了该函数名下同一抽象层上的步骤，则函数还是只做了一件事，因此要确保函数只做一件事情的话，函数中的语句都要在同一个抽象层级上面*

### Switch语句

```java
public Money calculatePay(Employee e) throws InvalidEmployeeType{
  switch(e.type){
      case COMMISSIONED:
					return calculateCommissionedPay(e);
			case HOURLY:
					return calculateHourlyPay(e);
			case SALARIED:
					return calculateSalariedPay(e);
			default:
					throw new InvalidEmployeeType(e.type);
  }
}
```

此函数存在的问题是：

1. 首先，它太长，当出现新的雇员类型时，会更长

2. 其次，做了明显不止一件事情

3. 违反了单一权责原则（SRP），因为有好几个修改它的理由
4. 违反了开放闭合原则（OCP），每当添加一个新类型，就必须修改
5. 最麻烦的是，可能存在多个地方，会有相似的switch的type的判断，如方法isPayday()

该问题解决方案为：

​	将switch*语句埋在抽象工厂底下，不让任何人看到，该工厂使用switch语句为Employee的派生类创建适合的实体，其他的函数藉由Employee接口多态的接受派遣*

​	对于switch语句，如果只是出现一次，用于创建多态对象，而且隐藏在某个继承关系中，在系统其他的部分看不到，就还可以忍受。

整理后代码如下：

```java
public abstract class Employee{
  public abstract boolean isPayday();
  public abstract Money calculatePay();
}
------------
public interface EmployeeFactory{
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}
------------
public class EmployeeFactoryImpl implements EmployeeFactory{
  public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType{
    switch(r.type){
        case COMMISSIONED:
					return calculateCommissionedPay(r);
				case HOURLY:
					return calculateHourlyPay(r);
				case SALARIED:
					return calculateSalariedPay(r);
				default:
					throw new InvalidEmployeeType(r.type); 
    }
  }
}
```

### 函数参数

***最理想的参数数量是0，其次是1，再次是2，应尽量避免3，有足够特殊的理由才能使用3个以上的参数，所以无论如何也不要这么做***

从单元测试的角度看，参数叫人为难，因为参数越多，需要测试的参数组合就越多

输出参数比输入参数还要让人难以理解，读函数时，我们惯于认为信息通过参数输入函数，通过返回值从函数中输出。我们不太期望信息通过参数输出。应避免使用输出参数。如果函数必须要修改某种状态，就修改所属对象的状态吧。（**这里的意思就是说通过函数修改了其参数的内容**）

#### 标识参数（Boolean）

标识参数丑陋不堪。向函数传入布尔值简直就是骇人听闻的做法。这样做，方法签名立刻变得复杂起来，大声宣布本函数不止做一件事。如果标识为true将会这样做，标识为false则会那样做！

#### 参数对象

如果函数看来需要三个或者三个以上的参数，就说明其中一些参数应该封装为class了。

#### 无副作用

副作用是一种谎言。函数承诺只做一件事，但还是会做其他被藏起来的事。有时，它会对自己类中的变量做出未能预期的改动。有时，它会把变量搞成向函数传递的参数或是系统全局变量。无论哪种情况，都是具有破坏性的，会导致古怪的时序性耦合及顺序依赖。

如下函数：该函数使用标准算法来匹配 userName和password。如果匹配成功，返回 true，如果失败则返回 false。但它会有副作用

```java
public class UserValidator {
		private Cryptographer cryptographer;
		public boolean checkPassword(String userName, String password) {
				User user = UserGateway.findByName(userName);
				if (user != User.NULL) {
						String codedPhrase = user.getPhraseEncodedByPassword();
						String phrase = cryptographer.decrypt(codedPhrase, password);
						if ("Valid Password".equals(phrase)) {
								Session.initialize();
								return true;
						}
				}
				return false;
		}
}
```

这里副作用就在于对Session.initialize( )的调用。checkPassword函数，顾名思义，就是用来检查密码的。该名称并未暗示它会初始化该次会话。所以，当某个误信了函数名的调用者想要检查用户有效性时，就得*<font color="red">冒抹除现有会话数据的风险</font>*

### 分隔指令和询问

函数要么做什么事，要么回答什么事，二者不可兼得，就像上面的那样。

```java
public boolean set(String attribute, String value);
```

“该函数设置某个指定属性，如果成功就返回true，如果不存在那个属性则返回false。这样就导致了以下语句：

```java
if (set("username", "unclebob"))...
```

从读者的角度考虑一下吧。这是什么意思呢？它是在问username属性值是否之前已设置为unclebob吗？或者它是在问username属性值是否成功设置为unclebob呢？

真正的解决方案是把指令与询问分隔开来，防止混淆的发生：

```java
if (attributeExists("username")) {
		setAttribute("username", "unclebob");
}
```

### 使用异常替代返回错误码

```java
if (deletePage(page) == E_OK) {
		if (registry.deleteReference(page.name) == E_OK) {
			if (configKeys.deleteKey(page.name.makeKey()) == E_OK){
					logger.log("page deleted");
			} else {
				logger.log("configKey not deleted");
			}
		} else {
			logger.log("deleteReference from registry failed");
		}
} else {
	logger.log("delete failed");
	return E_ERROR;
}
```

错误码会导致更深层次的嵌套的结构。当返回错误码的时候，就是在要求调用者立刻处理错误。

如果使用异常替代返回错误码，错误处理代码就能从主路径代码中分离出来，得到简化：

```java
try{
	deletePage(page);
	registry.deleteReference(page.name);
	configKeys.deleteKey(page.name.makeKey);
}catch(Exception e){
	logger.log(e.getMessage());
}
```

#### 抽离try/catch代码块

try/catch代码块丑陋不堪，她们扰乱了代码结构，把错误处理与正常流程混为一谈。因此最好把try和catch代码块的主体部分抽离出来，另外形成函数

```java
try{
  deletePageAndAllReferences(page);
}catch(Exception e){
  logError(e);
}
```

#### 错误处理就是一件事

函数只做一件事情，错误处理就是一件事。<font color="red">***如果try在某个函数中存在，它就该是这个函数的第一个单词，而且在catch/finally代码块后面也不该有其他的内容***</font>

#### 别重复自己

## 第四章 注释

***别给糟糕的代码加注释-重新写吧***

每当要写注释的时候，看看能不能使用代码来表达意思

注释不能美化糟糕的代码，用代码来阐述注释的意思

能使用函数或者变量来表示意思时就别用注释

注释掉的代码：导致其他人不敢删除代码，我们删除掉即可，通过git他们丢不了

## 第五章 格式

## 第六章 对象和数据结构

***变量设置成私有的理由：我们不想别人依赖这些变量，不要直接给变量设置赋值器和取值器，如同它们根本就是公共变量一样***

### 数据抽象

隐藏实现并非只是在变量之间放上一个函数层那么简单。隐藏关乎抽象，类并不简单地用取值器和赋值器将其变量推向外间，而是曝露抽象接口，以便用户无需了解数据的实现就能操作数据本体。

如下：你能确定前者里面都是些变量存取器，而却无法得知后者中的数据形态。

```java
public interface Vehicle{
	double getFuelTankCapacityInGallons();
	double getGallonsOfGasoline();
}
```

```java
public interface Vehicle {
	double getPercentFuelRemaining();
}
```

要以最好的方式呈现某个对象包含的数据，<font color="red">需要做严肃的思考，傻乐着加 取/赋值器，是最坏的选择</font>

### 数据 对象反对称性

对象把数据隐藏于抽象之后，曝露操作数据的函数。数据结构曝露其数据，没有提供有意义的函数

***过程式代码(使用数据结构的代码)便于在不改动既有数据结构的前提下添加新函数；面向对象代码；便于在不改动既有函数的前提下添加新类***

或者说：过程式代码难以添加新数据结构，因为必须修改所有函数。面向对象代码难以添加新函数，因为必须修改所有类。

在任何一个复杂系统中，都会有需要添加新数据类型而不是新函数的时候。这时，对象和面向对象就比较适合。另一方面，也会有想要添加新函数而不是数据类型的时候。在这种情况下，过程式代码和数据结构更合适。

### 得墨忒耳律

***模块不应当了解它所操作的对象的内部的情形***， 这意味着对象不应当通过存取器暴露其内部结构

类C的方法f函数只应该调用**以下对象**的方法

- C

- 由f创建的对象

- 作为参数传递给f的对象

- 由C的实体变量持有的对象

方法不应该调用任何函数返回的对象的方法。换言之，只跟朋友交谈，不与陌生人交谈

**火车头失事**

```java
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
```

违反得墨忒耳律，这类代码常被称作火车失事，因为它看起来就像是一列火车。这类连串的调用通常被认为是肮脏的风格，应该避免

*如果ctxt、Options和ScratchDir只是数据结构，没有任何行为，则它们自然会曝露其内部结构，**得墨忒耳律也就不适用了***

**隐藏结构**

上面的火车失事的代码，可以查看下最后取得outputDir是需要干嘛的，可以考虑取的outputDir后操作的代码放在ctxt对象中，这样就可以避免了，例如

```java
BufferedOutputStream bos = ctxt.createScratchFileStream(classFileName);
```

### 数据传送对象

最为精练的数据结构，是一个只有公共变量、没有函数的类。这种数据结构有时被称为数据传送对象，或DTO（Data Transfer Objects）。DTO是非常有用的结构。

更常见的是如下代码所示的“豆”（bean）结构。豆结构拥有由赋值器和取值器操作的私有变量。对豆结构的半封装会让某些OO纯化论者感觉舒服些，不过通常没有其他好处。

```java
public class Address {
  private String street;

  public Address(String street) {
    this.street = street;
	}
  public String getStreet() {
  	return street;
	}
}
```

### 小结

对象曝露行为，隐藏数据。便于添加新对象类型而无需修改既有行为，同时也难以在既有对象中添加新行为。数据结构曝露数据，没有明显的行为。便于向既有数据结构添加新行为，同时也难以向既有函数添加新数据结构。

